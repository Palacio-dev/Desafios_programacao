#include <bits/stdc++.h>
#include <cmath>
using namespace std;
typedef long long ll;
typedef vector<int> vi ;
typedef map<int,int> mii;

ll _sieve_size;
bitset <10000010> bs ; // 10^7 should be enough f o r most cases
vi primes ; // compact l i s t o f primes i n form of vector < i n t >

void sieve (ll upperbound){ // c reate l i s t o f primes i n [ 0 . . upperbound ]
    _sieve_size = upperbound + 1; // add 1 to inc lude upperbound
    bs.set() ; // se t a l l b i t s to 1
    bs [0] = bs [1] = 0 ; // except index 0 and 1
    for (ll i = 2 ; i <= _sieve_size ;i ++) if (bs [i]){

        // cross out m u l t i p l e s o f i s t a r t i n g from i * i !
        for (ll j = i * i ; j <= _sieve_size ; j += i ) bs [j] = 0 ;
        primes.push_back (( int ) i) ; // a lso add t h i s vec to r con ta in ing l i s t o f primes

    } 
} // c a l l t h i s method i n main method

bool isPrime (ll N) { // a good enough d e t e r m i n i s t i c prime t e s t e r
    if (N <= _sieve_size) return bs [N] ; // O( 1 ) f o r smal l primes
    for (int i = 0 ; i < ( int )primes.size();i ++)
        if (N % primes[i] == 0) return false ;
    return true ; // i t takes longer t ime i f N i s a la rge prime !
} // note : on ly work f o r N <= ( l a s t prime i n v i " primes " ) ^2



vi primeFactors (ll N) { // remember : v i i s vec to r o f in tegers , l l i s long long
    vi factors ; // v i primes ( generated by s ieve ) i s o p t i o n a l
    ll PF_idx = 0 , PF = primes [ PF_idx ] ; // using PF = 2 , 3 , 4 , . . . , i s a lso ok
    while (N != 1 && (PF * PF <= N) ) { // s top a t s q r t (N) , but N can get smal le r
        while (N % PF == 0) { N /= PF ; factors.push_back (PF) ; } // remove t h i s PF
        PF = primes [++ PF_idx ] ; // on ly cons ider primes !
    }
    if (N != 1) factors.push_back (N) ; // spec ia l case i f N i s a c t u a l l y a prime
    return factors ; // i f p f exceeds 32âˆ’b i t i n teger , you have to change v i
}


int gcd(int a , int b){return b == 0 ? a : gcd (b, a % b);}
int lcm (int a , int b){return a * (b / gcd (a , b));}


ll EulerPhi(ll N){
    ll PF_idx = 0 , PF = primes [ PF_idx ] , ans = N; // s t a r t from ans = N
    while (N != 1 && (PF * PF <= N) ) {
        if (N % PF == 0) ans -= ans / PF ; // on ly count unique f a c t o r
        while (N % PF == 0) N /= PF ;
        PF = primes [++ PF_idx ] ;
    }
    if (N != 1) ans -= ans / N; // l a s t f a c t o r
    return ans ;
}


int main(){
    sieve (10000000) ; // can go up to 10^7 ( need few seconds )
    ll t, n, res;
    cin >> t;
    while (t--){
        cin >> n;
        res = EulerPhi(n);
        cout << res << endl;
    }


}

